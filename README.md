# cakeTimer

---

목차 
1. 프로젝트 개요
2. 도입 전과 도입 후 비교
3. 주요 기술적 이슈와 해결 과정
4. 아쉬웠던 점

---

### 1. 프로젝트 개요
저는 투썸플레이스에스에서 아르바이트를 했었습니다. 여기서는 홀케익이 매출에서 차지하는 비중이 상당히 큽니다. 그렇기에 평소에도 많은 케익 주문이 들어오는데 일반적인 음료 제조와는 한 가지 다른 점이 있습니다. 해동이 덜 된 상태의 케익이 고객에게 인도되면 안 된다는 점입니다. 홀케익의 해동 시간은 6시간 정도로 예를 들어 오늘 오후 2시에 쇼케이스에 진열했다면 오후 8시 전까지는 고객에게 설명 없이 판매되어서는 안 됩니다. 이를 위해 기존에는 쇼케이스 진열 시간을 타임스탬프로 케익 판 뒷면에 붙여 관리했었는데 이는 케익 판매 시 그리고 케익 진열 시에 상당한 불편한 점이 있었습니다. 그래서 현재 시간 - 진열 시간 = "해동 경과 시간"을 자동으로 관리해주는 앱을 만들어보았고 이는 다음 목차에서 설명하는 효과를 가져왔습니다.

---

### 2. 도입 전과 도입 후 비교
cakeTimer 도입 전  
<img width="1356" alt="스크린샷 2025-01-19 오후 5 38 52" src="https://github.com/user-attachments/assets/498f6b65-49e4-4b6e-87e6-a903cf0aa27f" />

<img width="1361" alt="스크린샷 2025-01-19 오후 5 39 01" src="https://github.com/user-attachments/assets/8ebe0dea-08f1-4792-8e46-a0044261059d" />

cakeTimer 도입 후  
<img width="983" alt="스크린샷 2025-01-19 오후 5 29 29" src="https://github.com/user-attachments/assets/6179f350-fe4b-4ed6-bd81-31d114752569" />
<img width="990" alt="스크린샷 2025-01-19 오후 5 30 23" src="https://github.com/user-attachments/assets/1a928ea9-3072-40f2-a75e-b0e2dec2f082" />

cakeTimer를 도입하자 고객 응대 시 잠시 양해를 구한 뒤 쇼케이스에서 시간을 확인하는 프로세스가 없어져 훨씬 효율적으로 응대할 수 있었습니다. 무엇보다도 시간을 일일이 확인하고 타임스티커를 붙이는 업무가 아예 사라져서 특히 관리자 직급(매니저, 점장)의 만족도가 매우 높았습니다.  
전혀 예상치 못한 효과도 있었는데 전화 응대가 훨씬 간편해졌다는 점입니다. 이전까지는 전화 케익 주문 예약을 받으려면 손님께 잠시 양해를 구한 후 해동이 된 케익이 뭔지 전부 확인을 하고 다시 응대를 해야 했는데 전화기 옆에 제 앱이 있었기 때문에 바로바로 응대를 함으로써 훨씬 효율적으로 전화주문에 대응할 수 있었습니다.

---

### 3. 주요 기술적 이슈와 해결과정

#### 3-1) Provider로 해결한 케이크 상태 관리 문제

처음에는 간단히 생각했습니다. 그냥 한 화면에 모든 케익을 고정된 상태로 표시하면 되는 것 아닌가? 어차피 쇼케이스에 들어가는 케익은 최대 8개니까 타이머 객체 8개를 단순히 한 화면에 표시해주면 되겠다 싶어 gridview를 사용해서 초기 버전을 개발했지만 막상 사용자 피드백을 받고 나니 아래와 같은 문제가 있었습니다.

- 해동 중인 케익, 해동이 끝난 케익, 판매가 완료된 케익 이 세 가지 상태가 전부 뒤섞여 있어 보기가 어렵다.

실제로 초기 구현본은 8개 케익의 위치가 모두 고정된 상태로 동적이지 않았기 때문에 상태 구별이 어려웠습니다. 그래서 Provider를 도입했습니다. Provider가 최상단에서 데이터를 들고 있고 해동 중 및 해동 완료 페이지를 따로 구현하여 이 페이지에서 상태 변화가 있을 경우 이를 감지하여 다시 Provider가 각각의 해동 중 리스트와 해동 완료 리스트를 만드는 식으로 설계를 바꿔 대응하였고, 다시 실사용자 피드백을 받았을 때에도 훨씬 보기가 편해졌다는 응답을 들을 수 있었습니다.  
저 혼자 개발할 때는 모르고 놓쳤던 부분이었는데 사용자 피드백을 통해 미처 생각 못했던 부분을 개선할 수 있었고 Provider 패턴을 통한 구조적 개선으로 실제 사용성을 향상시킨 소중한 경험이었습니다.

<img width="997" alt="스크린샷 2025-04-14 오후 1 13 37" src="https://github.com/user-attachments/assets/640011ce-eae1-4aa0-a041-8a3fa1cc6992" />

#### 3-2) 시시각각 변동되는 케익 리스트를 어떻게 관리할 것인가?

초기 구현본을 만들 때 간과했던 점이 1가지 더 있었습니다. 알바를 시작한 지 얼마 안 되어 잘 몰랐던 사실이었는데 쇼케이스에 들어가는 케익의 총 수는 8개의 고정값이지만 그 종류는 시시각각 바뀐다는 점이었습니다. 예를 들어 오늘은 a, b, c, d, e, f, g, h 8개의 케익을 판매할지라도 당장 내일이 되면 g 케익은 재고 소진이나 단종으로 인해 빠질 수도 있고, z 케익 신제품이 나와 h 케익 자리를 대체할 수도 있습니다. 케익 추가 기능이야 초기 구현본을 만들면서 자연스럽게 구현했던 기능이라 별 문제가 아니였습니다만, 앱이 꺼졌다가 다시 켜지더라도 화면에 보이는 리스트가 꺼지기 전과 같아야 했습니다. 단순히 Provider 안에 있는 Elpased & Elapsing list를 업데이트한다고 될 문제가 아니었던 것입니다.

그래서 displayonlist flag를 도입하여 shared_preference에 저장해놓았다가 displayonlist flag가 true일 경우에만 리스트에 보이도록 코드를 수정하였고, 그제서야 비로소 실사용을 할 수 있게 되었습니다.
해결책 자체는 단순했지만, 단순히 앱이 실행되고 있을 때의 상태뿐만 아니라 앱이 RAM에 올라오고 나서 내려가기까지의 전반적 생애주기를 고려하는 기초적 시각을 길러준 경험이 되었습니다.

#### 3-3) human error와 software error를 어떻게 보완할 것인가?

사람은 필연적으로 실수합니다. 알바생도 마찬가지입니다. 특히나 저희 지점의 경우에는 근처에 행사장 및 공연장이 있어 아이돌들이 상시 출몰하는 지역이었습니다. 행사가 있을 때마다 행사 전후로 50 ~ 80명 가량의 손님들이 한꺼번에 몰려드는데 그 상황을 매주 직접 겪으면서 이 앱을 쓰는 알바생은 반드시 실수할 것이라는 확신을 가졌습니다. 또한, 이 앱을 만드는 저도 사람이기 때문에 분명 어딘가에는 버그가 숨어 있을 것이라 생각했고 따라서, 실제 현장에 투입시켰을 때 앱 자체가 오작동하는 상황도 고려해야 했습니다. 이 문제는 다음과 같이 해결했습니다.  

Human error
- 해동 중 or 해동 완료 상태에서 사용자가 cake을 터치하면 판매 완료 상태로 변경됩니다. 이때 판매 완료를 하기 전에 알림창을 띄워 정말 이 케익을 판매 완료하려는 것이 맞는지 묻는 프로세스를 추가했습니다.
- 때로는 사용자가 터치 자체를 잘못할 수도 있습니다. 그래서, 케익을 길게 누르면 케익별 상세 설정에서 이전 시간 복구 버튼을 통해 사용자의 실수를 바로잡을 수 있도록 조치하였습니다.

Software error
- 어떤 이유로 인해 케익을 터치해도 시간 조작을 할 수 없다든지, 아예 케익 상태가 보이지 않는 상황이라면 사실상 앱을 쓸 수가 없습니다.
- 그래서 shared_preference에 저장되어 있는 데이터들을 최소한의 가공만 거쳐 화면에 Display하는 "Emergency list" 기능을 설정에 추가하여 앱 오류 상황에서도 안에 저장된 데이터를 보고 타임스티커를 만들 수 있도록 조치하였습니다.

다행스럽게도 Emergency list가 실제 현장에서 쓰이는 일은 없었고 Human error도 상당 부분 방지할 수 있었는데 심지어 개발자인 저도 이 앱을 사용하면서 human error 방지 기능의 수혜를 몇 번 받았습니다.  
개발자인 저조차도 앱을 사용하면서 제가 만든 human error 방지 기능의 수혜를 받는 아이러니한 경험을 하면서 사용자는 무조건 실수를 한다는 가정 하에 소프트웨어 설계를 해야 한다는 깨달음을 얻을 수 있었습니다.


---

4. 아쉬웠던 점

4-1) 근본적으로 잘못된 DB 선택  
메인 DB로 shared_preference를 선택하였는데 이는 치명적 실책이였습니다. shared_preference는 간단한 데이터를 저장하는 데 적합하고 따라서 단순히 해동 시작 시간만 기록하면 되는 것 아니냐는 근시안적인 생각으로 선택했는데 앱의 확장성을 고려하지 않아 수많은 문제를 야기했지만 그중에서도 일주일이라는 시간을 삭제해버린 문제가 있었습니다.

- 하이픈과 언더바
데이터를 저장할 때 "cakename-$id" 형태의 키를 사용했습니다. id는 uuid로 각 케익에 부여된 고유한 번호값입니다. 이때 저장된 데이터를 불러올 때는 하이픈(-)을 기준으로 문자열을 분할한 후, 마지막 부분을 ID로 가져오는 방식(split('-').last)을 사용했습니다.
~~~ dart
      if (key.startsWith('cakename-')) {
        String id = key.split('-').last;
        int? display = prefs.getInt('displayonlist_$id');
        if (cakeName != null && display != null) {
          if (display == 1) {
            _cakeDisplay[cakeName] = true;
          } else {
            _cakeDisplay[cakeName] = false;
          }
        }
      }
~~~

그러나 uuid의 형태는 하이픈을 기준으로 여러 부분으로 나뉘어져 있습니다(예: "kdfj-dkjfkd-dfjkd"). 따라서 key.split('-').last를 사용하면 전체 UUID가 아닌 마지막 부분인 "dfjkd"만 ID로 인식됩니다.
이로 인해 예를 들어 "cakename-kdfj-dkjfkd-dfjkd"라는 키가 있을 때, key.split('-').last로는 "dfjkd"만 ID로 인식되어 나머지 부분인 "kdfj-dkjfkd"는 손실됩니다. 결과적으로 잘못된 키를 조회하게 되어 원래 저장된 데이터를 제대로 불러오지 못하는 문제가 발생했습니다. 이후 데이터를 삭제할 때도 마찬가지로 전체 UUID가 아닌 일부분만 사용하게 되어 올바른 데이터를 제거할 수 없게 되었습니다.  
이 문제 때문에 제 맥에 설치된 가상 android 기기에 저장된 실제 shared_preference까지 열어보기까지 해야 했습니다. 해결은 간단하게 하이픈을 언더바로 변경하여 해결했지만, 애초에 Hive나 SQlite를 썼더라면 훨씬 더 확장성 있는 구조를 가져감과 동시에 이러한 문제는 애초에 발생하지 않았을 것입니다. 적절한 도구의 선택이 시간의 절약을 불러온다는 것을 몸소 깨닫는 계기가 되었습니다.




